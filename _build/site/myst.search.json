{"version":"1","records":[{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE PYSCENE DATA üï∞Ô∏è"},"type":"lvl1","url":"/group-editing-copy1","position":0},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE PYSCENE DATA üï∞Ô∏è"},"content":"import matplotlib.pyplot as plt\n\nimport pandas as pd\nimport seaborn as sns\n\n\ndf= pd.read_csv(\"../output/scenes_data.tsv\", sep='\\t')\n\ndf[\"season\"] = df[\"episode\"].str.extract(r's(\\d+)', expand=False).astype(int)\ndf[\"episode_short\"] = df[\"episode\"].str.extract(r'(s\\d+e\\d+)', expand=False).str.upper()\nmean_duration = df.groupby(\"episode_short\", as_index=False)[\"duration\"].mean()\n\n\n","type":"content","url":"/group-editing-copy1","position":1},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE PYSCENE DATA üï∞Ô∏è","lvl2":"AVERAGE DURATION üï∞Ô∏è OF SEGMENTS PER EPISODES"},"type":"lvl2","url":"/group-editing-copy1#average-duration-of-segments-per-episodes","position":2},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE PYSCENE DATA üï∞Ô∏è","lvl2":"AVERAGE DURATION üï∞Ô∏è OF SEGMENTS PER EPISODES"},"content":"\n\nplt.figure(figsize=(20, 8))\nax = sns.barplot(data=mean_duration, x=\"episode_short\", y=\"duration\", palette=\"viridis\")\nax.set_xticks(ax.get_xticks()[::5])  # show every 5th label\nax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha=\"right\")\nplt.title(\"Average duration of scenes per episode\")\nplt.ylabel(\"Average duration (s)\")\nplt.xlabel(\"Episodes\")\nplt.tight_layout()\nplt.show()\n\n\n\nscene_count = df.groupby(\"episode_short\")[\"scene_number\"].count().reset_index(name=\"num_scenes\")\n\n","type":"content","url":"/group-editing-copy1#average-duration-of-segments-per-episodes","position":3},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE PYSCENE DATA üï∞Ô∏è","lvl2":"NUMBER OF SCENES üß© IN EPISODES"},"type":"lvl2","url":"/group-editing-copy1#number-of-scenes-in-episodes","position":4},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE PYSCENE DATA üï∞Ô∏è","lvl2":"NUMBER OF SCENES üß© IN EPISODES"},"content":"\n\nplt.figure(figsize=(20, 8))\nax = sns.barplot(data=scene_count, x=\"episode_short\", y=\"num_scenes\", palette=\"viridis\")\nax.set_xticks(ax.get_xticks()[::5])  # show every 5th label\nax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha=\"right\")\nax.set_yticks(range(0, 500, 50)) \nplt.title(\"n of scenes per episode\")\nplt.ylabel(\" n of scenes\")\nplt.xlabel(\"Episodes\")\nplt.tight_layout()\nplt.show()\n\nepisode_durations = df.groupby(\"episode_short\")[\"duration\"].sum().reset_index(name=\"episode_duration\")\n\n","type":"content","url":"/group-editing-copy1#number-of-scenes-in-episodes","position":5},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE PYSCENE DATA üï∞Ô∏è","lvl2":"DURATION OF EPISODES üï∞Ô∏è"},"type":"lvl2","url":"/group-editing-copy1#duration-of-episodes","position":6},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE PYSCENE DATA üï∞Ô∏è","lvl2":"DURATION OF EPISODES üï∞Ô∏è"},"content":"\n\nplt.figure(figsize=(20, 8))\nax = sns.barplot(data=episode_durations, x=\"episode_short\", y=\"episode_duration\", palette=\"viridis\")\nax.set_xticks(ax.get_xticks()[::5])  # show every 5th label\nax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha=\"right\")\nplt.title(\"Duration of episodes\")\nplt.ylabel(\"Duration (s)\")\nplt.xlabel(\"Episodes\")\nplt.tight_layout()\nplt.show()\n\n\n","type":"content","url":"/group-editing-copy1#duration-of-episodes","position":7},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE PYSCENE DATA üï∞Ô∏è","lvl2":"SCENES DURATIONS üï∞Ô∏è"},"type":"lvl2","url":"/group-editing-copy1#scenes-durations","position":8},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE PYSCENE DATA üï∞Ô∏è","lvl2":"SCENES DURATIONS üï∞Ô∏è"},"content":"\n\nimport pandas as pd\nimport plotly.graph_objects as go\n\n# Sort seasons\nseasons = sorted(df['season'].unique())\n\n# Create figure\nfig = go.Figure()\nall_traces = []\n\n# Track how many episodes per season (for visibility masks)\nseason_trace_counts = []\n\n# Create violin traces for each season's episodes\nfor season in seasons:\n    filtered_df = df[df['season'] == season]\n    episodes = sorted(filtered_df['episode_short'].unique())\n    trace_count = 0\n    \n    for ep in episodes:\n        ep_df = filtered_df[filtered_df['episode_short'] == ep]\n\n        trace = go.Violin(\n            x=[ep] * len(ep_df),\n            y=ep_df['duration'],\n            name=f\"Ep {ep}\",\n            box_visible=True,\n            meanline_visible=True,\n            points=\"all\",\n            visible=(season == seasons[0]),  # Only show first season initially\n            customdata=ep_df[['global_scene_number', 'duration']].values,\n            hovertemplate=(\n                \"Episode: %{x}<br>\" +\n                \"Global scene: %{customdata[0]}<br>\" +\n                \"Duration: %{customdata[1]} seconds<br>\" +\n                \"<extra></extra>\"  # hides the trace name in the tooltip\n    )\n)\n        fig.add_trace(trace)\n        trace_count += 1\n\n    season_trace_counts.append(trace_count)\n\n# Compute visibility masks for each season\n# Compute visibility masks for each season\nvisibility_masks = []\ntotal_traces = sum(season_trace_counts)\nstart = 0\nfor count in season_trace_counts:\n    mask = [False] * total_traces\n    for i in range(count):\n        mask[start + i] = True\n    visibility_masks.append(mask)\n    start += count\n\n\n# Create dropdown buttons\ndropdown_buttons = [\n    dict(\n        label=f\"Season {season}\",\n        method=\"update\",\n        args=[\n            {\"visible\": visibility_masks[i]},\n            {\"title\": f\"Scene Duration ‚Äì Season {season}\"}\n        ]\n    )\n    for i, season in enumerate(seasons)\n]\n\n# Update layout\nfig.update_layout(\n    updatemenus=[\n        dict(\n            active=0,\n            buttons=dropdown_buttons,\n            x=0.1,\n            y=1.15,\n            xanchor=\"left\",\n            yanchor=\"top\"\n        )\n    ],\n    title=f\"Scene Duration ‚Äì Season {seasons[0]}\",\n    xaxis_title=\"Episode\",\n    yaxis_title=\"Duration (seconds)\",\n    width=1200,\n    height=600,\n    showlegend=False\n)\n\nfig.show()\n\n\nimport pandas as pd\nimport plotly.graph_objects as go\n\n# Sort seasons\nseasons = sorted(df['season'].unique())\n\n# Create figure\nfig = go.Figure()\nseason_trace_count = []\n\n# Add one scatter trace per season\nfor i, season in enumerate(seasons):\n    filtered_df = df[df['season'] == season]\n\n    trace = go.Scatter(\n        x=filtered_df['global_scene_number'],\n        y=filtered_df['duration'],\n        mode='markers',\n        name=f\"Season {season}\",\n        customdata=filtered_df[['episode_short', 'scene_number']],\n        hovertemplate=(\n            \"Global Scene: %{x}<br>\" +\n            \"Duration: %{y} seconds<br>\" +\n            \"Episode: %{customdata[0]}<br>\" +\n            \"Scene: %{customdata[1]}<br>\" +\n            \"<extra></extra>\"\n        ),\n        visible=(i == 0)  # Only show first season initially\n    )\n    fig.add_trace(trace)\n\n# Create visibility masks for dropdown\nvisibility_masks = [\n    [i == j for i in range(len(seasons))]\n    for j in range(len(seasons))\n]\n\n# Create dropdown buttons\ndropdown_buttons = [\n    dict(\n        label=f\"Season {season}\",\n        method=\"update\",\n        args=[\n            {\"visible\": visibility_masks[i]},\n            {\"title\": f\"Scene Duration ‚Äì Season {season}\"}\n        ]\n    )\n    for i, season in enumerate(seasons)\n]\n\n# Update layout\nfig.update_layout(\n    updatemenus=[\n        dict(\n            active=0,\n            buttons=dropdown_buttons,\n            x=0.1,\n            y=1.2,\n            xanchor=\"left\",\n            yanchor=\"top\"\n        )\n    ],\n    title=f\"Scene Duration ‚Äì Season {seasons[0]}\",\n    xaxis_title=\"Global Scene Number\",\n    yaxis_title=\"Duration (seconds)\",\n    width=1200,\n    height=600\n)\n\nfig.show()\n","type":"content","url":"/group-editing-copy1#scenes-durations","position":9},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE MANUAL SEGMENTATION DATA üï∞Ô∏è"},"type":"lvl1","url":"/group-manual-seg-copy1","position":0},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE MANUAL SEGMENTATION DATA üï∞Ô∏è"},"content":"import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport plotly.express as px\nimport friends_pack\n\ndf= pd.read_csv(\"../output/manual_segmentation_all.tsv\", sep='\\t')\n\n#add frames to onset and offset time\nfps = 29.97\ndf['onset_frame'] = (df['onset']*fps).round().astype(int)\ndf['offset_frame'] = (df['offset'] * fps).round().astype(int)\ndf[\"season\"] = df[\"episode\"].str.extract(r's(\\d+)', expand=False).astype(int)\n\nnum_segments = df.groupby(\"episode_full\").size().reset_index(name='num_segments')\n\n\n","type":"content","url":"/group-manual-seg-copy1","position":1},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE MANUAL SEGMENTATION DATA üï∞Ô∏è","lvl2":"NUMBER OF SEGMENTS üß© IN EPISODES"},"type":"lvl2","url":"/group-manual-seg-copy1#number-of-segments-in-episodes","position":2},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE MANUAL SEGMENTATION DATA üï∞Ô∏è","lvl2":"NUMBER OF SEGMENTS üß© IN EPISODES"},"content":"\n\nplt.figure(figsize=(20, 8))\nax = sns.barplot(data=num_segments, x=\"episode_full\", y=\"num_segments\", palette=\"viridis\")\nax.set_xticks(ax.get_xticks()[::5])  # show every 5th label\nax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha=\"right\")\nplt.title(\"Number of segments per episode\")\nplt.ylabel(\"n of segments\")\nplt.xlabel(\"Episodes\")\nplt.tight_layout()\nplt.show()\n\n","type":"content","url":"/group-manual-seg-copy1#number-of-segments-in-episodes","position":3},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE MANUAL SEGMENTATION DATA üï∞Ô∏è","lvl2":"AVERAGE DURATION üï∞Ô∏è OF SEGMENTS PER EPISODES"},"type":"lvl2","url":"/group-manual-seg-copy1#average-duration-of-segments-per-episodes","position":4},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE MANUAL SEGMENTATION DATA üï∞Ô∏è","lvl2":"AVERAGE DURATION üï∞Ô∏è OF SEGMENTS PER EPISODES"},"content":"\n\n#average duration of scenes per episode for manual segementation\nmean_duration = df.groupby(\"episode_full\")[\"duration\"].mean().reset_index()\n\n\nplt.figure(figsize=(20, 8))\nax = sns.barplot(data=mean_duration, x=\"episode_full\", y=\"duration\", palette=\"viridis\")\nax.set_xticks(ax.get_xticks()[::5])  # show every 5th label\nax.set_xticklabels(ax.get_xticklabels(), rotation=45, ha=\"right\")\nplt.title(\"Average duration of segments per episode\")\nplt.ylabel(\"Average duration (s)\")\nplt.xlabel(\"Episodes\")\nplt.tight_layout()\nplt.show()\n\n\n","type":"content","url":"/group-manual-seg-copy1#average-duration-of-segments-per-episodes","position":5},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE MANUAL SEGMENTATION DATA üï∞Ô∏è","lvl2":"NUMBER OF SEGMENTS üß© PER LOCATION üìçüßõ‚Äç‚ôÇÔ∏è"},"type":"lvl2","url":"/group-manual-seg-copy1#number-of-segments-per-location","position":6},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE MANUAL SEGMENTATION DATA üï∞Ô∏è","lvl2":"NUMBER OF SEGMENTS üß© PER LOCATION üìçüßõ‚Äç‚ôÇÔ∏è"},"content":"\n\nlocation_columns = ['loc_apt1_Mon_Rach', 'loc_apt2_Chan_Joey', 'loc_apt3_Ross', 'loc_apt4_Pheob_Rach',\t'loc_coffeeshop', 'loc_outside', 'loc_other'] \nfriends_pack.boolean_True_plotter(df,location_columns, 'Number of Segments per Location', 'Location', 'Number of segments')\n\n","type":"content","url":"/group-manual-seg-copy1#number-of-segments-per-location","position":7},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE MANUAL SEGMENTATION DATA üï∞Ô∏è","lvl2":"NUMBER OF SEGMENTS üß© PER ONBOUND/OFFBOUND"},"type":"lvl2","url":"/group-manual-seg-copy1#number-of-segments-per-onbound-offbound","position":8},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE MANUAL SEGMENTATION DATA üï∞Ô∏è","lvl2":"NUMBER OF SEGMENTS üß© PER ONBOUND/OFFBOUND"},"content":"\n\nonbound_columns = ['ONbond_location', 'ONbond_charact_entry', 'ONbond_charact_leave', 'ONbond_time_jump', 'ONbond_goal_change', 'ONbond_music_transit',\t'ONbond_theme_song','ONbond_end']\nfriends_pack.boolean_True_plotter(df,onbound_columns, 'Number of segments per ONbound type', 'Onbound type', 'Number of segments')\n\noffbound_columns = ['OFFbond_location',\t'OFFbond_charact_entry', 'OFFbond_charact_leave',\t'OFFbond_time_jump', 'OFFbond_goal_change',\t'OFFbond_music_transit',\t'OFFbond_theme_song',\t'OFFbond_end']\nfriends_pack.boolean_True_plotter(df,offbound_columns, 'Number of segments per OFFbound type', 'Offbound type', 'Number of segments')\n\nlocation_cols = [col for col in df.columns if col.startswith('loc_')]\nid_vars = ['duration', 'season',] \ndf_melted = df.melt(id_vars=['duration', 'season', 'global_segment'],\n                    value_vars=location_cols,\n                    var_name='location',\n                    value_name='is_location')\n\ndf_true = df_melted[df_melted['is_location'] == True]\n\n\n\navg_duration = df_true.groupby('location')['duration'].mean().reset_index()\n\n\n\n\n","type":"content","url":"/group-manual-seg-copy1#number-of-segments-per-onbound-offbound","position":9},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE MANUAL SEGMENTATION DATA üï∞Ô∏è","lvl2":"AVERAGE SEGMENT DURATION AND SEGMENT üß© DURATION üï∞Ô∏è BY LOCATION üìçüßõ‚Äç‚ôÇÔ∏è"},"type":"lvl2","url":"/group-manual-seg-copy1#average-segment-duration-and-segment-duration-by-location","position":10},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE MANUAL SEGMENTATION DATA üï∞Ô∏è","lvl2":"AVERAGE SEGMENT DURATION AND SEGMENT üß© DURATION üï∞Ô∏è BY LOCATION üìçüßõ‚Äç‚ôÇÔ∏è"},"content":"\n\nplt.figure(figsize=(10,6))\nsns.barplot(data=avg_duration, x='location', y='duration', palette='viridis')\nplt.xticks(rotation=45, ha='right')\nplt.title('Average Duration by Location')\nplt.ylabel('Average Duration')\nplt.xlabel('Location')\nplt.tight_layout()\nplt.show()\n\n\nimport plotly.graph_objects as go\n\n# Sort seasons\nseasons = sorted(df_true['season'].unique())\nfig = go.Figure()\n\n# Add one violin plot per season (but only first season is visible by default)\nfor i, season in enumerate(seasons):\n    filtered_df = df_true[df_true['season'] == season]\n\n    fig.add_trace(go.Violin(\n        y=filtered_df[\"duration\"],\n        x=filtered_df[\"location\"],\n        name=f\"Season {season}\",\n        box_visible=True,\n        meanline_visible=True,\n        points=\"all\",\n        hovertext=filtered_df[\"global_segment\"],\n        visible=(i == 0),\n        customdata=filtered_df[['global_segment', 'duration']].values,\n            hovertemplate=(\n                \"location: %{x}<br>\" +\n                \"Global segment: %{customdata[0]}<br>\" +\n                \"Duration: %{customdata[1]} seconds<br>\" +\n                \"<extra></extra>\"  # hides the trace name in the tooltip\n    )))\n\n# Create dropdown buttons to toggle seasons\ndropdown_buttons = [\n    dict(\n        label=f\"Season {season}\",\n        method=\"update\",\n        args=[\n            {\"visible\": [i == j for j in range(len(seasons))]},\n            {\"title\": f\"Segment Duration by Location ‚Äì Season {season}\"}\n        ]\n    )\n    for i, season in enumerate(seasons)\n]\n\n# Update layout with dropdown and labels\nfig.update_layout(\n    updatemenus=[dict(\n        buttons=dropdown_buttons,\n        active=0,\n        x=0.1,\n        y=1.2,\n        xanchor=\"left\",\n        yanchor=\"top\"\n    )],\n    xaxis_title=\"Location\",\n    yaxis_title=\"Duration (seconds)\",\n    title=f\"Segment Duration by Location ‚Äì Season {seasons[0]}\",\n    width=1200,\n    height=600\n)\n\nfig.show()\n\n\nON_cols = [col for col in df.columns if col.startswith('ONbond_')]\nid_vars2 = ['duration', 'season',] \ndf_melted2 = df.melt(id_vars=['duration', 'season', 'global_segment'],\n                    value_vars=ON_cols,\n                    var_name='Onbond',\n                    value_name='is_Onbond')\n\ndf_true2 = df_melted2[df_melted2['is_Onbond'] == True]\n\n\n\n","type":"content","url":"/group-manual-seg-copy1#average-segment-duration-and-segment-duration-by-location","position":11},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE MANUAL SEGMENTATION DATA üï∞Ô∏è","lvl2":"SEGMENT üß© DURATION üï∞Ô∏è FOR ONBOUND/OFFBOUND TYPE"},"type":"lvl2","url":"/group-manual-seg-copy1#segment-duration-for-onbound-offbound-type","position":12},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE MANUAL SEGMENTATION DATA üï∞Ô∏è","lvl2":"SEGMENT üß© DURATION üï∞Ô∏è FOR ONBOUND/OFFBOUND TYPE"},"content":"\n\n# Sort seasons\nseasons = sorted(df_true2['season'].unique())\nfig = go.Figure()\n\n# Add one violin plot per season (but only first season is visible by default)\nfor i, season in enumerate(seasons):\n    filtered_df2 = df_true2[df_true2['season'] == season]\n\n    fig.add_trace(go.Violin(\n        y=filtered_df2[\"duration\"],\n        x=filtered_df2[\"Onbond\"],\n        name=f\"Season {season}\",\n        box_visible=True,\n        meanline_visible=True,\n        points=\"all\",\n        hovertext=filtered_df2[\"global_segment\"],\n        visible=(i == 0),\n        customdata=filtered_df2[['global_segment', 'duration']].values,\n            hovertemplate=(\n                \"Onbond: %{x}<br>\" +\n                \"Global segment: %{customdata[0]}<br>\" +\n                \"Duration: %{customdata[1]} seconds<br>\" +\n                \"<extra></extra>\"  # hides the trace name in the tooltip\n    )))\n\n# Create dropdown buttons to toggle seasons\ndropdown_buttons = [\n    dict(\n        label=f\"Season {season}\",\n        method=\"update\",\n        args=[\n            {\"visible\": [i == j for j in range(len(seasons))]},\n            {\"title\": f\"Segment Duration by Onbound‚Äì Season {season}\"}\n        ]\n    )\n    for i, season in enumerate(seasons)\n]\n\n# Update layout with dropdown and labels\nfig.update_layout(\n    updatemenus=[dict(\n        buttons=dropdown_buttons,\n        active=0,\n        x=0.1,\n        y=1.2,\n        xanchor=\"left\",\n        yanchor=\"top\"\n    )],\n    xaxis_title=\"Onbound\",\n    yaxis_title=\"Duration (seconds)\",\n    title=f\"Segment Duration by Onbound ‚Äì Season {seasons[0]}\",\n    width=1200,\n    height=600\n)\n\nfig.show()\n\n\n","type":"content","url":"/group-manual-seg-copy1#segment-duration-for-onbound-offbound-type","position":13},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE MANUAL SEGMENTATION DATA üï∞Ô∏è","lvl2":"SEGMENT üß© DURATION üï∞Ô∏è"},"type":"lvl2","url":"/group-manual-seg-copy1#segment-duration","position":14},{"hierarchy":{"lvl1":"üï∞Ô∏è ALL ABOUT DURATIONS AND SEGMENTATION IN THE MANUAL SEGMENTATION DATA üï∞Ô∏è","lvl2":"SEGMENT üß© DURATION üï∞Ô∏è"},"content":"\n\nimport pandas as pd\nimport plotly.graph_objects as go\n\n# Group your data by season\nseasons = sorted(df['season'].unique())\nfig = go.Figure()\n\n# Create one trace per season, initially only show the first\nfor i, season in enumerate(seasons):\n    season_df = df[df['season'] == season]\n    visible = (i == 0)  # Only first season is visible by default\n\n    fig.add_trace(go.Scatter(\n        x=season_df[\"global_segment\"],\n        y=season_df[\"duration\"],\n        mode=\"markers\",\n        name=f\"Season {season}\",\n        visible=visible,\n        customdata=season_df[['global_segment', 'duration']].values,\n            hovertemplate=(\n                \"location: %{x}<br>\" +\n                \"Global segment: %{customdata[0]}<br>\" +\n                \"Duration: %{customdata[1]} seconds<br>\" +\n                \"<extra></extra>\"  # hides the trace name in the tooltip\n    )))\n\n# Create dropdown buttons\ndropdown_buttons = [\n    dict(\n        label=f\"Season {season}\",\n        method=\"update\",\n        args=[\n            {\"visible\": [i == j for j in range(len(seasons))]},\n            {\"title\": f\"Segment Duration ‚Äì Season {season}\"}\n        ]\n    )\n    for i, season in enumerate(seasons)\n]\n\n# Add dropdown to layout\nfig.update_layout(\n    updatemenus=[dict(\n        active=0,\n        buttons=dropdown_buttons,\n        x=0.1,\n        y=1.15,\n        xanchor='left',\n        yanchor='top'\n    )],\n    xaxis_title=\"Global Segment\",\n    yaxis_title=\"Duration (seconds)\",\n    title=f\"Segment Duration ‚Äì Season {seasons[0]}\",\n    width=1000,\n    height=600\n)\n\n\nfig.show()","type":"content","url":"/group-manual-seg-copy1#segment-duration","position":15},{"hierarchy":{"lvl1":"MACHINE GAZINGü§ñüëÅÔ∏è‚Äçüó®Ô∏è‚ú®"},"type":"lvl1","url":"/group-saliency-copy1","position":0},{"hierarchy":{"lvl1":"MACHINE GAZINGü§ñüëÅÔ∏è‚Äçüó®Ô∏è‚ú®"},"content":"import matplotlib.pyplot as plt\nimport numpy as np\n\n\n\n\nimport pandas as pd\nimport seaborn as sns\n\n\n#read data set as pd\ndf= pd.read_csv(\"../output/Peak_scenes_merged.tsv\", sep='\\t')\n\n# Define the new bin edges and labels\ndf[\"episode_short\"] = df[\"episode\"].str.extract(r'(s\\d+e\\d+)', expand=False).str.upper()\nconditions = [\n    df['p'] == 1,\n    df['p'] == 2,\n    df['p'] == 3,\n    df['p'] > 3\n]\nlabels = ['1', '2', '3', '>3']\n\ndf['p_bin'] = np.select(conditions, labels, default='other') \n\n# Group by episode and binned p values, then count\nframe_counts = df.groupby(['episode_short', 'p_bin'], observed=True).size().unstack(fill_value=0)\n\n# Normalize to get the proportion of each p-bin per episode\nframe_proportions = frame_counts.div(frame_counts.sum(axis=1), axis=0)\n\n","type":"content","url":"/group-saliency-copy1","position":1},{"hierarchy":{"lvl1":"MACHINE GAZINGü§ñüëÅÔ∏è‚Äçüó®Ô∏è‚ú®","lvl2":"HEIGHT POSITION DENSITY (pixel space)"},"type":"lvl2","url":"/group-saliency-copy1#height-position-density-pixel-space","position":2},{"hierarchy":{"lvl1":"MACHINE GAZINGü§ñüëÅÔ∏è‚Äçüó®Ô∏è‚ú®","lvl2":"HEIGHT POSITION DENSITY (pixel space)"},"content":"\n\n# plot for Density of Height Positions Across Frames\nplt.figure(figsize=(12, 6))\nplt.hexbin(df[\"frame\"], df[\"h\"], gridsize=50, cmap=\"plasma\", mincnt=1)\nplt.gca().invert_yaxis()\nplt.colorbar(label=\"Counts\")\nplt.xlabel(\"Frame\")\nplt.ylabel(\"Height (h)\")\nplt.title(\"Density of Height Positions Across Frames\")\nplt.show()\n\n\n","type":"content","url":"/group-saliency-copy1#height-position-density-pixel-space","position":3},{"hierarchy":{"lvl1":"MACHINE GAZINGü§ñüëÅÔ∏è‚Äçüó®Ô∏è‚ú®","lvl2":"WIDTH POSITION DENSITY (pixel space)"},"type":"lvl2","url":"/group-saliency-copy1#width-position-density-pixel-space","position":4},{"hierarchy":{"lvl1":"MACHINE GAZINGü§ñüëÅÔ∏è‚Äçüó®Ô∏è‚ú®","lvl2":"WIDTH POSITION DENSITY (pixel space)"},"content":"\n\n# plot for Density of width Positions Across Frames\nplt.figure(figsize=(12, 6))\nplt.hexbin(df[\"frame\"], df[\"w\"], gridsize=50, cmap=\"plasma\", mincnt=1)\nplt.colorbar(label=\"Counts\")\nplt.xlabel(\"Frame\")\nplt.ylabel(\"Width (w)\")\nplt.title(\"Density of Width Positions Across Frames\")\nplt.show()\n\n\n# get stats on h and w depending on the scene_number\nscene_stats = df.groupby([\"episode_short\", \"global_scene_number\"]).agg({\n    \"h\": [\"mean\", \"std\", \"min\", \"max\"],\n    \"w\": [\"mean\", \"std\", \"min\", \"max\"]\n}).reset_index()\n\n# Optional: flatten multi-level columns\nscene_stats.columns = [\"episode_short\", \"global_scene_number\", \"h_mean\", \"h_std\", \"h_min\", \"h_max\",\n                       \"w_mean\", \"w_std\", \"w_min\", \"w_max\"]\n\n\n","type":"content","url":"/group-saliency-copy1#width-position-density-pixel-space","position":5},{"hierarchy":{"lvl1":"MACHINE GAZINGü§ñüëÅÔ∏è‚Äçüó®Ô∏è‚ú®","lvl2":"HEIGHT AND WIDTH DISTRIBUTION (pixel space)"},"type":"lvl2","url":"/group-saliency-copy1#height-and-width-distribution-pixel-space","position":6},{"hierarchy":{"lvl1":"MACHINE GAZINGü§ñüëÅÔ∏è‚Äçüó®Ô∏è‚ú®","lvl2":"HEIGHT AND WIDTH DISTRIBUTION (pixel space)"},"content":"\n\n#plot to show distribution of how much coordinates in scenes vary \nplt.figure(figsize=(12,5))\n\nplt.subplot(1,2,1)\nsns.histplot(scene_stats[\"h_std\"], bins=30, kde=True)\nplt.title(\"Distribution of Height STD per Scene\")\nplt.xlabel(\"Height STD (pixels)\")\n\nplt.subplot(1,2,2)\nsns.histplot(scene_stats[\"w_std\"], bins=30, kde=True)\nplt.title(\"Distribution of Width STD per Scene\")\nplt.xlabel(\"Width STD (pixels)\")\n\nplt.tight_layout()\nplt.show()\n\n\n","type":"content","url":"/group-saliency-copy1#height-and-width-distribution-pixel-space","position":7},{"hierarchy":{"lvl1":"MACHINE GAZINGü§ñüëÅÔ∏è‚Äçüó®Ô∏è‚ú®","lvl2":"GAZE DENSITY IN PIXEL SPACE"},"type":"lvl2","url":"/group-saliency-copy1#gaze-density-in-pixel-space","position":8},{"hierarchy":{"lvl1":"MACHINE GAZINGü§ñüëÅÔ∏è‚Äçüó®Ô∏è‚ú®","lvl2":"GAZE DENSITY IN PIXEL SPACE"},"content":"\n\n\n\nplt.figure(figsize=(8, 8))\nsns.kdeplot(\n    x=scene_stats[\"w_mean\"], \n    y=scene_stats[\"h_mean\"], \n    fill=True,  # fill the contours\n    cmap=\"viridis\",\n    thresh=0,   # show full density (no threshold)\n    levels=100  # number of contour levels (smoothness/detail)\n)\n\nplt.gca().invert_yaxis()\nplt.gca().invert_xaxis()\nplt.title(\"2D Density of Average Scene Positions (KDE)\")\nplt.xlabel(\"Mean Width (w)\")\nplt.ylabel(\"Mean Height (h)\")\nplt.tight_layout()\nplt.show()\n","type":"content","url":"/group-saliency-copy1#gaze-density-in-pixel-space","position":9},{"hierarchy":{"lvl1":"Introduction"},"type":"lvl1","url":"/paper","position":0},{"hierarchy":{"lvl1":"Introduction"},"content":"author: Cleo Lam","type":"content","url":"/paper","position":1},{"hierarchy":{"lvl1":"Introduction","lvl2":"GOAL"},"type":"lvl2","url":"/paper#goal","position":2},{"hierarchy":{"lvl1":"Introduction","lvl2":"GOAL"},"content":"This myst article gives a brief statistical description of\nseason 1-6 of the tv show Friends.\n\nTwo dimensions will be  explored, time and 2D space.","type":"content","url":"/paper#goal","position":3},{"hierarchy":{"lvl1":"Introduction","lvl2":"Background Music"},"type":"lvl2","url":"/paper#background-music","position":4},{"hierarchy":{"lvl1":"Introduction","lvl2":"Background Music"},"content":"A little background music from Ross From Friends:\n\nYour browser does not support the audio element.","type":"content","url":"/paper#background-music","position":5}]}